// ReSharper disable AutoPropertyCanBeMadeGetOnly.Global
// ReSharper disable PropertyCanBeMadeInitOnly.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
namespace Atc.Wpf.Controls.Documents.TextFormatters.SourceCode.Format;

/// <summary>
/// Provides a base implementation for all code formatters.
/// </summary>
/// <remarks>
/// <para>
/// To display the formatted code on your web site, the web page must
/// refer to a stylesheet that defines the formatting for the different
/// CSS classes generated by CSharpFormat:
/// .csharpcode, pre, .rem, .kwrd, .str, .op, .preproc, .alt, .lnum.
/// </para>
/// <para>
/// Note that if you have multi-line comments in your source code
/// (like /* ... */), the "line numbers" or "alternate line background"
/// options will generate code that is not strictly HTML 4.01 compliant.
/// The code will still look good with IE5+ or Mozilla 0.8+.
/// </para>
/// </remarks>
public abstract class Source
{
    /// <summary>
    /// Initializes a new instance of the <see cref="Source"/> class.
    /// </summary>
    protected Source()
    {
        this.TabSpaces = 4;
        this.LineNumbers = false;
        this.Alternate = false;
        this.EmbedStyleSheet = false;
    }

    /// <summary>
    /// Gets or sets the tabs width.
    /// </summary>
    /// <value>The number of space characters to substitute for tab
    /// characters. The default is <b>4</b>, unless overridden is a
    /// derived class.</value>
    public byte TabSpaces { get; set; }

    /// <summary>
    /// Enables or disables line numbers in output.
    /// </summary>
    /// <value>When <b>true</b>, line numbers are generated.
    /// The default is <b>false</b>.</value>
    public bool LineNumbers { get; set; }

    /// <summary>
    /// Enables or disables alternating line background.
    /// </summary>
    /// <value>When <b>true</b>, lines background is alternated.
    /// The default is <b>false</b>.</value>
    public bool Alternate { get; set; }

    /// <summary>
    /// Enables or disables the embedded CSS style sheet.
    /// </summary>
    /// <value>When <b>true</b>, the CSS &lt;style&gt; element is included
    /// in the HTML output. The default is <b>false</b>.</value>
    public bool EmbedStyleSheet { get; set; }

    /// <summary>
    /// The regular expression used to capture language tokens.
    /// </summary>
    [SuppressMessage("Security", "MA0009:Add regex evaluation timeout", Justification = "OK.")]
    protected Regex CodeRegex { get; set; } = new Regex("^");

    /// <summary>
    /// This is a List of Run's that can be added later to the string of code.
    /// </summary>
    [SuppressMessage("Usage", "CA2227:Collection properties should be read only", Justification = "OK.")]
    protected IList<Run> CodeParagraphGlobal { get; set; } = new List<Run>();

    /// <summary>
    /// Transforms a source code string to HTML 4.01.
    /// </summary>
    /// <param name="source">The source.</param>
    /// <returns>
    /// A string containing the HTML formatted code.
    /// </returns>
    public Paragraph FormatCode(string source)
    {
        return this.FormatCode(source, this.LineNumbers, this.Alternate, this.EmbedStyleSheet, false);
    }

    /// <summary>
    /// Called to evaluate the HTML fragment corresponding to each
    /// matching token in the code.
    /// </summary>
    /// <param name="match">The <see cref="Match" /> resulting from a
    /// single regular expression match.</param>
    /// <returns>A string containing the HTML code fragment.</returns>
    protected abstract string MatchEval(Match match);

    [SuppressMessage("Usage", "CA1801:Review unused parameters", Justification = "OK.")]
    private Paragraph FormatCode(string source, bool lineNumbers, bool alternate, bool embedStyleSheet, bool subCode)
    {
        var codeParagraph = new Paragraph();
        var sb = new StringBuilder(source);
        source = this.CodeRegex.Replace(sb.ToString(), this.MatchEval);
        string[] characters = { "::::::" };

        string[] split = source.Split(characters, StringSplitOptions.None);
        int currentChunk = 0;
        foreach (string code in split)
        {
            currentChunk++;
            var run = new Run(code);
            codeParagraph.Inlines.Add(run);
            if ((currentChunk - 1) < this.CodeParagraphGlobal.Count)
            {
                codeParagraph.Inlines.Add(this.CodeParagraphGlobal[currentChunk - 1]);
            }
        }

        return codeParagraph;
    }
}