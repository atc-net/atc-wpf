// ReSharper disable AutoPropertyCanBeMadeGetOnly.Global
// ReSharper disable PropertyCanBeMadeInitOnly.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
namespace Atc.Wpf.Controls.Documents.TextFormatters.SourceCode.Format;

/// <summary>
/// Provides a base implementation for all code formatters.
/// </summary>
/// <remarks>
/// <para>
/// To display the formatted code on your website, the web page must
/// refer to a stylesheet that defines the formatting for the different
/// CSS classes generated by CSharpFormat:
/// .csharpcode, pre, .rem, .kwrd, .str, .op, .preproc, .alt, .lnum.
/// </para>
/// <para>
/// Note that if you have multi-line comments in your source code
/// (like /* ... */), the "line numbers" or "alternate line background"
/// options will generate code that is not strictly HTML 4.01 compliant.
/// The code will still look good with IE5+ or Mozilla 0.8+.
/// </para>
/// </remarks>
public abstract class Source
{
    /// <summary>
    /// Initializes a new instance of the <see cref="Source"/> class.
    /// </summary>
    protected Source()
    {
        TabSpaces = 4;
        LineNumbers = false;
        Alternate = false;
        EmbedStyleSheet = false;
    }

    /// <summary>
    /// Gets or sets the tabs width.
    /// </summary>
    /// <value>The number of space characters to substitute for tab
    /// characters. The default is <b>4</b>, unless overridden is a
    /// derived class.</value>
    public byte TabSpaces { get; set; }

    /// <summary>
    /// Enables or disables line numbers in output.
    /// </summary>
    /// <value>When <b>true</b>, line numbers are generated.
    /// The default is <b>false</b>.</value>
    public bool LineNumbers { get; set; }

    /// <summary>
    /// Enables or disables alternating line background.
    /// </summary>
    /// <value>When <b>true</b>, lines background is alternated.
    /// The default is <b>false</b>.</value>
    public bool Alternate { get; set; }

    /// <summary>
    /// Enables or disables the embedded CSS style sheet.
    /// </summary>
    /// <value>When <b>true</b>, the CSS &lt;style&gt; element is included
    /// in the HTML output. The default is <b>false</b>.</value>
    public bool EmbedStyleSheet { get; set; }

    /// <summary>
    /// The regular expression used to capture language tokens.
    /// </summary>
    [SuppressMessage("Security", "MA0009:Add regex evaluation timeout", Justification = "OK.")]
    protected Regex CodeRegex { get; set; } = new("^");

    /// <summary>
    /// This is a List of Run's that can be added later to the string of code.
    /// </summary>
    [SuppressMessage("Usage", "CA2227:Collection properties should be read only", Justification = "OK.")]
    protected IList<Run> CodeParagraphGlobal { get; set; } = new List<Run>();

    /// <summary>
    /// Transforms a source code string to HTML 4.01.
    /// </summary>
    /// <param name="source">The source.</param>
    /// <param name="themeMode">The ThemeMode.</param>
    /// <returns>
    /// A string containing the HTML formatted code.
    /// </returns>
    public Paragraph FormatCode(string source, ThemeMode themeMode)
    {
        return FormatCodeHelper(source, themeMode);
    }

    /// <summary>
    /// Called to evaluate the HTML fragment corresponding to each
    /// matching token in the code.
    /// </summary>
    /// <param name="match">The <see cref="Match" /> resulting from a
    /// single regular expression match.</param>
    /// <param name="themeMode">The ThemeMode.</param>
    /// <returns>A string containing the HTML code fragment.</returns>
    protected abstract string MatchEval(Match match, ThemeMode themeMode);

    private Paragraph FormatCodeHelper(string source, ThemeMode themeMode)
    {
        var codeParagraph = new Paragraph();
        var sb = new StringBuilder(source);
        source = CodeRegex.Replace(sb.ToString(), match => MatchEval(match, themeMode));
        string[] characters = ["::::::"];

        var split = source.Split(characters, StringSplitOptions.None);
        var currentChunk = 0;
        foreach (var code in split)
        {
            currentChunk++;
            var run = new Run(code);
            codeParagraph.Inlines.Add(run);
            if ((currentChunk - 1) < CodeParagraphGlobal.Count)
            {
                codeParagraph.Inlines.Add(CodeParagraphGlobal[currentChunk - 1]);
            }
        }

        return codeParagraph;
    }
}